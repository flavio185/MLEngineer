pipeline {
  agent any
  environment {
    WORKSPACE_NAME='data-masters-workspace'
    RESOURCE_GROUP='DataMasters'    
    REGION='us-central1'
    PROJECT_ID='mlopscase'
    REPOSITORY='mlopscase'
  }
  stages {
    stage('Connect to GCP ') {
      steps {
        script {
          withCredentials([file(credentialsId: 'GCLOUD_KEY_JSON', variable: 'GCLOUD_KEY_JSON')]) {
            sh '''
              #####
              GCLOUD_LOGIN_INFO=mlops-service-account@mlopscase.iam.gserviceaccount.com
              GCLOUD_PROJECT=mlopscase
              #cp $GCLOUD_KEY_JSON MLEngineer/GKE/Terraform/key.json
              gcloud auth activate-service-account $GCLOUD_LOGIN_INFO \
              --key-file=$GCLOUD_KEY_JSON --project=$GCLOUD_PROJECT
              export GOOGLE_APPLICATION_CREDENTIALS=$GCLOUD_KEY_JSON
              ####
            '''
          }
        }
      }
    }
    stage('Push image to Google Cloud Artifact Repository.') {
      steps {
        script {
          withCredentials([file(credentialsId: 'GCLOUD_KEY_JSON', variable: 'GCLOUD_KEY_JSON')]) {
            sh '''
              create_set_google_artifactory_repo () {
                if ( ! gcloud artifacts repositories  list | grep "$REPOSITORY" )  ; then  
                  echo "Repositório não existe. Abortando."
                  exit 1
                fi
                echo "Configurando repositório para push"
                sudo gcloud auth configure-docker $REGION-docker.pkg.dev --quiet
              }
              create_set_google_artifactory_repo

              git clone $GIT_PROJECT
              export PROJECT_DIR="$(echo $GIT_PROJECT | awk -F/ '{print $NF}'| sed 's/.git//g')"
              #Clone MLOPS project
              export MODEL_VERSION=$(cat $PROJECT_DIR/API/app/model_version.py | cut -d= -f2)
              cd $PROJECT_DIR
              export GITHUB_SHA=$(git rev-parse HEAD)
              IMAGE="$PROJECT_DIR:$MODEL_VERSION$GITHUB_SHA"
              CONTAINER_IMAGE="$REGION-docker.pkg.dev/$PROJECT_ID/$REPOSITORY/$IMAGE"
              echo "tageando imagem."
              sudo docker tag $IMAGE $CONTAINER_IMAGE
              echo "Build step: Publicando a imagem no Google Artifact Registry."  
              sudo docker push $CONTAINER_IMAGE
            '''
          }
        }
      }
    }
    stage('Deploy to GKE.') {
      steps {
        script {
          withCredentials([file(credentialsId: 'GCLOUD_KEY_JSON', variable: 'GCLOUD_KEY_JSON')]) {
            sh '''
              export CPU="200m"
              export MEM="512m"
              export PROBE_CONTEXT="/health"
              configure_kubectl (){
                echo "Build step: Configurando kubectl para o projeto."  
                CLUSTER_NAME=mlopscase-gke
                #
                gcloud container clusters \
                get-credentials $CLUSTER_NAME \
                --region $REGION
              }
              configure_kubectl
              configure_deployment_yaml () {   
                echo "Build step: Deploy the Docker image no GKE cluster."
                cd $WORKSPACE/$PROJECT_DIR/manifest
                cat deployment.yaml | 
                yq e ".metadata.name = \"${APP}\""  - |
                yq e ".metadata.labels.app = \"${APP}\""  - |
                yq e ".spec.selector.matchLabels.app = \"${APP}\""  - |
                yq e ".spec.template.metadata.labels.app = \"${APP}\""  - |
                yq e ".spec.template.spec.containers[].name = \"${APP}\""  - |
                yq e ".spec.template.spec.containers[].image = \"${CONTAINER_IMAGE}\""  - |
                yq e ".spec.template.spec.containers[].resources.requests.cpu = \"${CPU}\""  - |
                yq e ".spec.template.spec.containers[].resources.requests.memory = \"${MEM}\""  - |
                yq e ".spec.template.spec.containers[].livenessProbe.httpGet.path = \"${PROBE_CONTEXT}\""  - |
                yq e ".spec.template.spec.containers[].startupProbe.httpGet.path = \"${PROBE_CONTEXT}\""  - \
                > deployment_tmp.yaml
                cp deployment_tmp.yaml deployment.yaml
                rm -rf deployment_tmp.yaml; 
              }
              configure_deployment_yaml


              configure_service_yaml () {   
                echo "Build step: Deploy the Docker image no GKE cluster."
                cd $WORKSPACE/$PROJECT_DIR/manifest
                cat service_lb.yaml | 
                yq e ".metadata.name = \"${APP}\""  - |
                yq e ".metadata.labels.app = \"${APP}\""  - |
                yq e ".spec.selector.app = \"${APP}\""  - \
                > service_lb_tmp.yaml
                cp service_lb_tmp.yaml service_lb.yaml
                rm -rf service_lb_tmp.yaml 
              }
              configure_service_yaml


              echo "Build step: Deploy the Docker image no GKE cluster."
              apply_deployment () {
                echo "Build step: Aplicando configuração de deployment para o cluster GKE."   
                kubectl apply -f $WORKSPACE/$PROJECT_DIR/manifest/deployment.yaml 
              }
              apply_deployment

              echo "Build step: Deploy the Docker image no GKE cluster."
              apply_service () {
                echo "Build step: Aplicando configuração de deployment para o cluster GKE."   
                kubectl apply -f $WORKSPACE/$PROJECT_DIR/manifest/service_lb.yaml 
              }
              apply_service

              start_kubernetes_deploymentrollout () {
                echo "Build step: Aplicando configuração de deployment para o cluster GKE."   
                kubectl rollout restart deployment  $APP
              }
            '''
          }
        }
      }
      post {
        // Clean after build
        always {
            sh "sudo chmod -R 777 ."
            cleanWs(cleanWhenNotBuilt: false,
                    deleteDirs: true,
                    disableDeferredWipeout: true,
                    notFailBuild: true)
        }
      }
    }
  }
}